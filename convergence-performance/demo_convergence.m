clearvars; clc;

%% Basic setting
n = 6000;       %%% n = the number of nodes
K = 12;          %%% K = the number of communities
m = n/K;        %%% m = the community size

%% ground truth 
Xt = kron(sparse(eye(K)), ones(m)); 
Ht = kron(sparse(eye(K)),ones(m,1));

%% choose the parameters (\alpha,\beta,K)
if K == 4
    a = 18; b = 4;    %%%  choose the constants alpha, beta in p, q, resp.
elseif K == 8
    a = 36; b = 8;
else
    a = 54; b = 12;
end
p = a*log(n)/n;       %%%  p = the within-cluster connecting probability 
q = b*log(n)/n;       %%%  q = the across-cluster connecting probability       

%% generate an adjacency matrix A by the symmtric SBM
A = sparse(zeros(n));
for i = 1:K
    for j = i:K
      if i == j
         Am1 = rand(m); Am1 = tril(Am1,-1);                         
         Am1 = Am1' + Am1 + diag(diag(Am1));
         Am = sparse(Am1 < p);
         A((i-1)*m+1:i*m,(j-1)*m+1:j*m) = Am;
      else
         Am1 = rand(m); Am = sparse(Am1 < q);                         
         A((i-1)*m+1:i*m,(j-1)*m+1:j*m) = Am;
         A((j-1)*m+1:j*m,(i-1)*m+1:i*m) = Am'; 
      end
    end
end

%% choose the running algorithm
run_PPM = 1; max_iter_PPM = 0;

for repeat = 1:10 %%%% 
            %% initial point generated by the normal distribution
            H0 = randn(n,K); H0 = LP_MCAP(H0, n, K);
            maxiter = 1e2; tol = 1e-4; report_interval = 1; total_time = 1e3; print = 1;
            
            %% PPM for the MLE
             if run_PPM == 1
                opts = struct('T', maxiter, 'tol', tol, 'report_interval', report_interval,...
                            'total_time', total_time, 'print', print); %%% choose the parameters in PPM
                [H_PPM, iter_PPM, fval_collector_PPM, itergap_PPM] = PPM(A, H0, Ht, opts);
            end
            max_iter_PPM = max(max_iter_PPM, iter_PPM);
            
            
            %% plot convergence performance
            if run_PPM == 1
                 n1 = size(itergap_PPM, 2); 
                 h1 = semilogy(itergap_PPM(1:n1-1)+2e-8, '-s', 'LineWidth', 2, 'MarkerSize', 5); hold on;
                 set(h1, 'markerfacecolor', get(h1, 'color'));
            end

end 
xlim([0, round(max_iter_PPM*1.1)]); ylim([1e-8, 1e3]); 

set(gca,'FontSize', 11); % 'FontWeight', 'Bold')
xlabel('Iterations'); ylabel('Distance to ground truth');


